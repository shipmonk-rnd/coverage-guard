#!/usr/bin/env php
<?php declare(strict_types=1);

use PhpParser\ParserFactory;
use ShipMonk\CoverageGuard\Cli\CliParser;
use ShipMonk\CoverageGuard\Cli\CommandRegistry;
use ShipMonk\CoverageGuard\Cli\CommandRunner;
use ShipMonk\CoverageGuard\Cli\HelpRenderer;
use ShipMonk\CoverageGuard\Cli\ParameterResolver;
use ShipMonk\CoverageGuard\Command\CheckCommand;
use ShipMonk\CoverageGuard\Command\ConvertCommand;
use ShipMonk\CoverageGuard\Command\MergeCommand;
use ShipMonk\CoverageGuard\Command\PatchCoverageCommand;
use ShipMonk\CoverageGuard\Coverage\CoverageMerger;
use ShipMonk\CoverageGuard\CoverageGuard;
use ShipMonk\CoverageGuard\CoverageProvider;
use ShipMonk\CoverageGuard\Exception\ErrorException;
use ShipMonk\CoverageGuard\PathHelper;
use ShipMonk\CoverageGuard\Printer;
use ShipMonk\CoverageGuard\Report\ErrorFormatter;
use ShipMonk\CoverageGuard\Utils\ConfigResolver;
use ShipMonk\CoverageGuard\Utils\PatchParser;

$autoloadPaths = [
    __DIR__ . '/../vendor/autoload.php',
    __DIR__ . '/../../../autoload.php',
];

foreach ($autoloadPaths as $autoloadPath) {
    if (file_exists($autoloadPath)) {
        require $autoloadPath;
        break;
    }
}

$cwd = getcwd();
if ($cwd === false) {
    throw new LogicException('Cannot determine current working directory');
}

$stderrPrinter = Printer::create(STDERR, $argv);
$stdoutPrinter = Printer::create(STDOUT, $argv);

try {
    $patchParser = new PatchParser($cwd, $stderrPrinter);
    $configResolver = new ConfigResolver($cwd);
    $coverageProvider = new CoverageProvider($stderrPrinter);
    $pathHelper = new PathHelper($cwd);
    $phpParser = (new ParserFactory())->createForHostVersion();
    $coverageGuard = new CoverageGuard($stderrPrinter, $phpParser, $pathHelper, $patchParser, $coverageProvider);
    $errorFormatter = new ErrorFormatter($pathHelper, $stdoutPrinter);

    $registry = new CommandRegistry();
    $registry->register(new CheckCommand($configResolver, $coverageGuard, $errorFormatter));
    $registry->register(new MergeCommand($coverageProvider, new CoverageMerger(), $configResolver));
    $registry->register(new ConvertCommand($coverageProvider, $configResolver));
    $registry->register(new PatchCoverageCommand($stdoutPrinter, $patchParser, $configResolver, $coverageProvider));

    $parameterResolver = new ParameterResolver();

    $runner = new CommandRunner(
        $registry,
        new CliParser(),
        $parameterResolver,
        new HelpRenderer($parameterResolver)
    );
    $exitCode = $runner->run($argv, $stderrPrinter);
    exit($exitCode);

} catch (ErrorException $e) {
    $stderrPrinter->printLine('');
    $stderrPrinter->printLine('⚠️  <orange>Error:</orange> ' . $e->getMessage());
    $stderrPrinter->printLine('');
    exit(1);

} catch (Throwable $e) {
    $stderrPrinter->printLine('');
    $stderrPrinter->printLine('‼️  <red>Internal error:</red> ' . $e::class . ': ' . $e->getMessage());
    $stderrPrinter->printLine($e->getTraceAsString());
    exit(1);
}
